namespace FSharp.Finance.Personal

/// calculating the principal balance over time, taking into account the effects of charges, interest and fee
module Amortisation =

    open System
    open AppliedPayment
    open Calculation
    open DateDay
    open Formatting
    open Scheduling

    /// the status of the balance on a given offset day
    [<Struct; StructuredFormatDisplay("{Html}")>]
    type BalanceStatus =
        /// the balance has been settled in full
        | ClosedBalance
        /// the balance is open, meaning further payments will be required to settle it
        | OpenBalance
        /// due to an overpayment or a refund of charges, a refund is due
        | RefundDue
        /// HTML formatting to display the balance status in a readable format
        member bs.Html =
            match bs with
            | ClosedBalance -> "closed"
            | OpenBalance -> "open"
            | RefundDue -> "refund due"

    /// amortisation schedule item showing apportionment of payments to principal, fee, interest and charges
    type ScheduleItem = {
        /// the date of amortisation
        OffsetDate: Date
        /// any advance made on the current day, typically the principal on day 0 for a single-advance transaction
        Advances: int64<Cent> array
        /// any payment scheduled on the current day
        ScheduledPayment: ScheduledPayment
        /// the window during which a scheduled payment can be made; if the date is missed, the payment is late, but if the window is missed, the payment is missed
        Window: int
        /// any payment scheduled on the current day
        PaymentDue: int64<Cent>
        /// any payments actually made on the current day
        ActualPayments: ActualPayment array
        /// a payment generated by the system e.g. to calculate a settlement figure
        GeneratedPayment: GeneratedPayment
        /// the net effect of the scheduled and actual payments, or, for future days, what the net effect would be if the scheduled payment was actually made
        NetEffect: int64<Cent>
        /// the status based on the payments and net effect
        PaymentStatus: PaymentStatus
        /// the overall balance status
        BalanceStatus: BalanceStatus
        /// any new charges incurred between the previous amortisation day and the current day
        NewCharges: AppliedCharge array
        /// the portion of the net effect assigned to the charges
        ChargesPortion: int64<Cent>
        /// the simple interest accruable between the previous amortisation day and the current day
        SimpleInterest: decimal<Cent>
        /// the new interest charged between the previous amortisation day and the current day, less any initial interest
        NewInterest: decimal<Cent>
        /// the portion of the net effect assigned to the interest
        InterestPortion: int64<Cent>
        /// any fee rebate, on the final amortisation day, if the fee is pro-rated in the event of early settlement
        FeeRebate: int64<Cent>
        /// the portion of the net effect assigned to the fee
        FeePortion: int64<Cent>
        /// the portion of the net effect assigned to the principal
        PrincipalPortion: int64<Cent>
        /// the charges balance to be carried forward
        ChargesBalance: int64<Cent>
        /// the interest balance to be carried forward
        InterestBalance: decimal<Cent>
        /// the fee balance to be carried forward
        FeeBalance: int64<Cent>
        /// the principal balance to be carried forward
        PrincipalBalance: int64<Cent>
        /// the settlement figure as of the current day
        SettlementFigure: int64<Cent> voption
        /// the pro-rated fee as of the current day
        FeeRebateIfSettled: int64<Cent>
    }
    
    /// amortisation schedule item showing apportionment of payments to principal, fee, interest and charges
    module ScheduleItem =
        /// a default value with no data
        let initial = {
            OffsetDate = Unchecked.defaultof<Date>
            Advances = [||]
            ScheduledPayment = ScheduledPayment.zero
            Window = 0
            PaymentDue = 0L<Cent>
            ActualPayments = [||]
            GeneratedPayment = NoGeneratedPayment
            NetEffect = 0L<Cent>
            PaymentStatus = NoneScheduled
            BalanceStatus = OpenBalance
            SimpleInterest = 0m<Cent>
            NewInterest = 0m<Cent>
            NewCharges = [||]
            PrincipalPortion = 0L<Cent>
            FeePortion = 0L<Cent>
            InterestPortion = 0L<Cent>
            ChargesPortion = 0L<Cent>
            FeeRebate = 0L<Cent>
            PrincipalBalance = 0L<Cent>
            FeeBalance = 0L<Cent>
            InterestBalance = 0m<Cent>
            ChargesBalance = 0L<Cent>
            SettlementFigure = ValueNone
            FeeRebateIfSettled = 0L<Cent>
        }
        /// formats the schedule item as an HTML row
        let toHtmlRow offsetDay scheduleItem = $"""
    <tr style="text-align: right;">
        <td class="ci00">{offsetDay}</td>
        <td class="ci01" style="white-space: nowrap;">%A{scheduleItem.OffsetDate}</td>
        <td class="ci02">{scheduleItem.Advances |> Array.map formatCent |> Array.toStringOrNa}</td>
        <td class="ci03" style="white-space: nowrap;">{scheduleItem.ScheduledPayment}</td>
        <td class="ci04">{scheduleItem.Window}</td>
        <td class="ci05">{formatCent scheduleItem.PaymentDue}</td>
        <td class="ci06">{scheduleItem.ActualPayments |> Array.toStringOrNa |> _.Replace(" ", "&nbsp;")}</td>
        <td class="ci07">{scheduleItem.GeneratedPayment}</td>
        <td class="ci08">{formatCent scheduleItem.NetEffect}</td>
        <td class="ci09">{scheduleItem.PaymentStatus.Html.Replace(" ", "&nbsp;")}</td>
        <td class="ci10">{scheduleItem.BalanceStatus.Html.Replace(" ", "&nbsp;")}</td>
        <td class="ci11">{formatDecimalCent scheduleItem.SimpleInterest}</td>
        <td class="ci12">{formatDecimalCent scheduleItem.NewInterest}</td>
        <td class="ci13">{Array.toStringOrNa scheduleItem.NewCharges |> _.Replace(" ", "&nbsp;")}</td>
        <td class="ci14">{formatCent scheduleItem.PrincipalPortion}</td>
        <td class="ci15">{formatCent scheduleItem.FeePortion}</td>
        <td class="ci16">{formatCent scheduleItem.InterestPortion}</td>
        <td class="ci17">{formatCent scheduleItem.ChargesPortion}</td>
        <td class="ci18">{formatCent scheduleItem.FeeRebate}</td>
        <td class="ci19">{formatCent scheduleItem.PrincipalBalance}</td>
        <td class="ci20">{formatCent scheduleItem.FeeBalance}</td>
        <td class="ci21">{formatDecimalCent scheduleItem.InterestBalance}</td>
        <td class="ci22">{formatCent scheduleItem.ChargesBalance}</td>
        <td class="ci23">{scheduleItem.SettlementFigure |> ValueOption.map formatCent |> ValueOption.defaultValue "&nbsp;"}</td>
        <td class="ci24">{formatCent scheduleItem.FeeRebateIfSettled}</td>
    </tr>"""


    /// a container for aggregating figures separately from the main schedule
    [<Struct>]
    type Accumulator = {
        /// the total of scheduled payments up to the current day
        CumulativeScheduledPayments: int64<Cent>
        /// the total of actual payments made up to the current day
        CumulativeActualPayments: int64<Cent>
        /// the total of generated payments made up to the current day
        CumulativeGeneratedPayments: int64<Cent>
        /// the total fee paid up to the current day
        CumulativeFee: int64<Cent>
        /// the total of interest accrued up to the current day
        CumulativeInterest: decimal<Cent>
        /// the total of interest portions up to the current day
        CumulativeInterestPortions: int64<Cent>
        /// the total of simple interest accrued up to the current day
        CumulativeSimpleInterestM: decimal<Cent>
    }

    /// final statistics resulting from the calculations
    [<Struct>]
    type FinalStats = {
        /// the final number of scheduled payments in the schedule
        RequiredScheduledPaymentCount: int
        /// the offset day of the final required scheduled payment
        LastRequiredScheduledPaymentDay: int<OffsetDay> voption
        /// the final number of actual payments in the schedule (multiple payments made on the same day are counted separately)
        FinalActualPaymentCount: int
        /// the offset day of the final actual payment
        LastActualPaymentDay: int<OffsetDay> voption
        /// the final ratio of (fee + interest + charges) to principal
        FinalCostToBorrowingRatio: Percent
        /// the daily interest rate derived from interest over (principal + fee), ignoring charges 
        EffectiveInterestRate: Interest.Rate
    }

    /// final statistics resulting from the calculations
    module FinalStats =
        /// formats the schedule stats as an HTML table (excluding the items, which are rendered separately)
        let toHtmlTable finalStats = $"""
<table>
    <tr>
        <td>Effective interest rate: <i>{finalStats.EffectiveInterestRate}</i></td>
        <td>Final cost-to-borrowing ratio: <i>{finalStats.FinalCostToBorrowingRatio}</i></td>
    </tr>
    <tr>
        <td>Required scheduled payment count: <i>{finalStats.RequiredScheduledPaymentCount}</i></td>
        <td>Last required scheduled payment day: <i>{finalStats.LastRequiredScheduledPaymentDay}</i></td>
    </tr>
    <tr>
        <td>Final actual payment count: <i>{finalStats.FinalActualPaymentCount}</i></td>
        <td>Last actual payment day: <i>{finalStats.LastActualPaymentDay |> ValueOption.map string |> ValueOption.defaultValue "n/a"}</i></td>
    </tr>
</table>
"""

    /// a schedule showing the amortisation, itemising the effects of payments and calculating balances for each item, and producing some final statistics resulting from the calculations
    [<Struct>]
    type Schedule = {
        /// a list of amortisation items, showing the events and calculations for a particular offset day
        ScheduleItems: Map<int<OffsetDay>, ScheduleItem>
        /// final stats resulting from the calculations
        FinalStats: FinalStats
    }

    /// results of the amortisation schedule generation
    type GenerationResult = {
        AmortisationSchedule: Schedule
        SimpleSchedule: SimpleSchedule
    }

    /// a schedule showing the amortisation, itemising the effects of payments and calculating balances for each item, and producing some final statistics resulting from the calculations
    module Schedule =
        /// formats the schedule items as an HTML table (stats can be rendered separately)
        let toHtmlTable schedule = $"""
<table>
    <thead style="vertical-align: bottom;">
        <th style="text-align: right;">Day</th>
        <th style="text-align: right;">Datestamp</th>
        <th style="text-align: right;">Advances</th>
        <th style="text-align: right;">Scheduled payment</th>
        <th style="text-align: right;">Window</th>
        <th style="text-align: right;">Payment due</th>
        <th style="text-align: right;">Actual payments</th>
        <th style="text-align: right;">Generated payment</th>
        <th style="text-align: right;">Net effect</th>
        <th style="text-align: right;">Payment status</th>
        <th style="text-align: right;">Balance status</th>
        <th style="text-align: right;">Simple interest</th>
        <th style="text-align: right;">New interest</th>
        <th style="text-align: right;">New charges</th>
        <th style="text-align: right;">Principal portion</th>
        <th style="text-align: right;">Fee portion</th>
        <th style="text-align: right;">Interest portion</th>
        <th style="text-align: right;">Charges portion</th>
        <th style="text-align: right;">Fee rebate</th>
        <th style="text-align: right;">Principal balance</th>
        <th style="text-align: right;">Fee balance</th>
        <th style="text-align: right;">Interest balance</th>
        <th style="text-align: right;">Charges balance</th>
        <th style="text-align: right;">Settlement figure</th>
        <th style="text-align: right;">Fee rebate if&nbsp;settled</th>
    </thead>{schedule.ScheduleItems |> Map.map ScheduleItem.toHtmlRow |> Map.values |> String.concat ""}
</table>
"""

        /// renders the schedule as an HTML table within a markup file, which can both be previewed in VS Code and imported as XML into Excel
        let outputHtmlToFile folder title description sp (schedules: GenerationResult) =
            let htmlTitle = $"<h2>{title}</h2>"
            let htmlSchedule = toHtmlTable schedules.AmortisationSchedule
            let htmlDescription = $"""
<h4>Description</h4>
<p><i>{description}</i></p>"""
            let htmlParams = $"""
<h4>Parameters</h4>{Parameters.toHtmlTable sp}"""
            let htmlDatestamp = $"""
<p>Generated: <i>{DateTime.Now.ToString "yyyy-MM-dd"} using library version {Calculation.libraryVersion}</i></p>"""
            let htmlFinalStats = $"""
<h4>Initial Stats</h4>{InitialStats.toHtmlTable schedules.SimpleSchedule.Stats}"""
            let htmlAmortisationStats = $"""
<h4>Final Stats</h4>{FinalStats.toHtmlTable schedules.AmortisationSchedule.FinalStats}"""
            let filename = $"out/{folder}/{title}.md"
            $"{htmlTitle}{htmlSchedule}{htmlDescription}{htmlDatestamp}{htmlParams}{htmlFinalStats}{htmlAmortisationStats}"
            |> outputToFile' filename false

    /// calculates the fee total as a percentage of the principal, for further calculation (weighting payments made when apportioning to fee and principal)
    let feePercentage principal feeTotal =
        if principal = 0L<Cent> then
            Percent 0m
        else
            decimal feeTotal / decimal principal |> Percent.fromDecimal

    /// gets the balance status based on the principal balance
    let getBalanceStatus principalBalance =
        if principalBalance = 0L<Cent> then
            ClosedBalance
        elif principalBalance < 0L<Cent> then
            RefundDue
        else
            OpenBalance

    /// determines whether a schedule is settled within any grace period (e.g. no interest may be due if settlement is made within three days of the advance)
    let isSettledWithinGracePeriod sp settlementDay =
        match settlementDay with
        | SettlementDay.SettlementOn day ->
            int day <= int sp.InterestConfig.InitialGracePeriod
        | SettlementDay.SettlementOnAsOfDay ->
            int <| OffsetDay.fromDate sp.StartDate sp.AsOfDate <= int sp.InterestConfig.InitialGracePeriod
        | SettlementDay.NoSettlement ->
            false

    /// pattern matching for payments due vs payments made
    let (|NotPaidAtAll|SomePaid|FullyPaid|) (actualPaymentTotal, paymentDueTotal) =
        if actualPaymentTotal = 0L<Cent> then
            NotPaidAtAll
        elif actualPaymentTotal < paymentDueTotal then
            SomePaid (paymentDueTotal - actualPaymentTotal)
        else
            FullyPaid

    /// modifies missed payments or underpayments to reflect whether they are paid later in full or part or not at all within the payment window
    /// note: this is useful for credit reporting so as not to penalise those who pay late rather than not at all
    let markMissedPaymentsAsLate (schedule: Map<int<OffsetDay>, ScheduleItem>) =
        schedule
        |> Map.toArray
        |> Array.groupBy (snd >> _.Window)
        |> Array.map snd
        |> Array.filter (Array.isEmpty >> not)
        |> Array.map(fun v ->
            {|
                OffsetDay = v |> Array.head |> fst
                PaymentDueTotal = v |> Array.sumBy (snd >> _.PaymentDue)
                ActualPaymentTotal = v |> Array.sumBy (snd >> _.ActualPayments >> Array.sumBy ActualPayment.total)
                GeneratedPaymentTotal = v |> Array.sumBy (snd >> _.GeneratedPayment >> GeneratedPayment.Total)
                PaymentStatus = v |> Array.head |> snd |> _.PaymentStatus
            |}
        )
        |> Array.filter(fun a -> a.PaymentStatus = MissedPayment || a.PaymentStatus = Underpayment)
        |> Array.choose(fun a ->
            match a.ActualPaymentTotal + a.GeneratedPaymentTotal, a.PaymentDueTotal with
            | NotPaidAtAll ->
                None
            | SomePaid shortfall ->
                Some (a.OffsetDay, PaidLaterOwing shortfall)
            | FullyPaid ->
                Some (a.OffsetDay, PaidLaterInFull)
        )
        |> Map.ofArray
        |> fun m ->
            if m |> Map.isEmpty then
                schedule
            else
                schedule
                |> Map.map(fun d si ->
                    match m |> Map.tryFind d with
                    | Some cps -> { si with PaymentStatus = cps }
                    | None -> si
                )

    /// calculates the total fee payable up to a particular day, based on a proportion of days elapsed vs total number of days in the original schedule
    let calculateFee feeTotal appliedPaymentDay originalFinalPaymentDay =
        if originalFinalPaymentDay <= 0<OffsetDay> then
            0L<Cent>
        elif appliedPaymentDay > originalFinalPaymentDay then
            0L<Cent>
        else
            decimal feeTotal * (decimal originalFinalPaymentDay - decimal appliedPaymentDay) / decimal originalFinalPaymentDay
            |> Cent.round RoundUp
            |> Cent.max 0L<Cent>

    /// determines any payment due on the day
    let calculatePaymentDue si originalPayment rescheduledPayment extraPaymentsBalance interestPortionL minimumPayment =
        // if the balance is closed or a refund is due, no payment is due
        if si.BalanceStatus = ClosedBalance || si.BalanceStatus = RefundDue then
            0L<Cent>
        // otherwise, calculate the payment due based on scheduled payments and various balances
        else
            match originalPayment, rescheduledPayment with
            // always make rescheduled payment value due in full
            | _, ValueSome rp ->
                rp.Value
            // if the original payment is cancelled due to rescheduling, there nothing is due
            | ValueSome op, _ when op = 0L<Cent> ->
                0L<Cent>
            // reduce the payment due if early/extra payments have been made
            | ValueSome op, _ when extraPaymentsBalance > 0L<Cent> ->
                op - extraPaymentsBalance
            // non-zero original payments are due in full
            | ValueSome op, _
                -> op
            // if there are no original or rescheduled payments on the day, there is nothing due to pay
            | ValueNone, ValueNone ->
                0L<Cent>
            // payment due should never exceed settlement figure
            |> Cent.min (si.PrincipalBalance + si.FeeBalance + interestPortionL)
            // payment due should never be negative
            |> Cent.max 0L<Cent>
            // apply minimum payment rules
            |> fun p ->
                match minimumPayment with
                | NoMinimumPayment -> p
                | DeferOrWriteOff minimumPayment when p < minimumPayment -> 0L<Cent>
                | ApplyMinimumPayment minimumPayment when p < minimumPayment -> p
                | _ -> p

    /// for UK FCA-regulated agreements, calculates the fee rebate due
    let calculateStatutoryFeeRebate sp (appliedPayments: Map<int<OffsetDay>, AppliedPayment>) initialStats appliedPaymentDay window =
        let originalScheduledPayments =
            appliedPayments
            |> Map.filter(fun _ ap -> ap.ScheduledPayment.Original.IsSome)
            |> Map.toArray
            |> Array.mapi(fun i (d, ap) -> {| Window = i; OffsetDay = d; OriginalScheduledPaymentValue = ap.ScheduledPayment.Original.Value |})
        let unitPeriod =
            match sp.ScheduleConfig with
            | AutoGenerateSchedule ags ->
                UnitPeriod.Config.unitPeriod ags.UnitPeriodConfig
            | FixedSchedules _
            | CustomSchedule _ ->
                let finalScheduledPaymentDate = initialStats.LastScheduledPaymentDay |> OffsetDay.toDate sp.StartDate
                let transactionTerm = UnitPeriod.transactionTerm sp.StartDate sp.StartDate finalScheduledPaymentDate sp.StartDate
                let paymentDates = originalScheduledPayments |> Array.map (_.OffsetDay >> OffsetDay.toDate sp.StartDate)
                UnitPeriod.nearest transactionTerm [| sp.StartDate |] paymentDates
        let previousScheduledPaymentDate = originalScheduledPayments |> Array.filter(fun osp -> osp.OffsetDay <= appliedPaymentDay) |> Array.last |> _.OffsetDay
        let numerator = appliedPaymentDay - previousScheduledPaymentDate |> int
        let denominator = UnitPeriod.roughLength unitPeriod
        let settlementPartPeriod = Fraction.Simple(numerator, denominator)
        let payments = originalScheduledPayments |> Array.map(fun osp -> osp.Window, osp.OriginalScheduledPaymentValue)
        Interest.calculateRebate sp.Principal payments initialStats.InitialApr window settlementPartPeriod unitPeriod sp.PaymentConfig.Rounding

    /// calculates an amortisation schedule detailing how elements (principal, fee, interest and charges) are paid off over time
    let internal calculate sp settlementDay initialStats (appliedPayments: Map<int<OffsetDay>, AppliedPayment>) =
        // get the as-of day (the day the schedule is inspected) based on the as-of date in the schedule parameters
        let asOfDay = (sp.AsOfDate - sp.StartDate).Days * 1<OffsetDay>
        // get the decimal initial interest balance (interest is generally calculated as a decimal until concretised as an interest portion, at which point it is rounded to an integer)
        let initialInterestBalanceM = Cent.toDecimalCent initialStats.InitialInterestBalance
        // calculate the total fee value for the entire schedule
        let feeTotal = Fee.total sp.FeeConfig sp.Principal
        // gets an array of daily interest rates for a given date range, taking into account grace periods and promotional rates
        let dailyInterestRates fromDay toDay = Interest.dailyRates sp.StartDate (isSettledWithinGracePeriod sp settlementDay) sp.InterestConfig.StandardRate sp.InterestConfig.PromotionalRates fromDay toDay
        // get the interest rounding method from the schedule parameters (usually it is advisable to round interest down to avoid exceeding caps)
        let interestRounding = sp.InterestConfig.Rounding
        // get stats for interest rounding at the end of the schedule
        let maxAppliedPaymentDay = appliedPayments |> Map.keys |> Seq.max
        let appliedPaymentCount = appliedPayments |> Map.count
        // return the amortisation schedule
        appliedPayments
        // convert the map to an array to allow scanning
        |> Map.toArray
        // generate the amortisation schedule
        |> Array.scan(fun ((siOffsetDay, si), a) (appliedPaymentDay, ap) ->
            // determine the window and increment every time a new scheduled payment is due
            let window = if ScheduledPayment.isSome ap.ScheduledPayment then si.Window + 1 else si.Window
            // get an array of advances
            // note: assumes single advance on day 0 (multiple advances are not currently supported), so this is based purely on the principal
            let advances = if appliedPaymentDay = 0<OffsetDay> then [| sp.Principal |] else [||]
            // calculates the simple interest that has accrued since the previous item
            let simpleInterestM =
                // if the principal balance is negative, apply any rate on negative balances and disregard any daily interest caps
                if si.PrincipalBalance <= 0L<Cent> then
                    dailyInterestRates siOffsetDay appliedPaymentDay
                    |> Array.map(fun dr -> { dr with InterestRate = sp.InterestConfig.RateOnNegativeBalance })
                    |> Interest.calculate (si.PrincipalBalance + si.FeeBalance) Amount.Unlimited interestRounding
                // otherwise, apply the daily interest rates as normal, applied daily caps as necessary
                else
                    dailyInterestRates siOffsetDay appliedPaymentDay
                    |> Interest.calculate (si.PrincipalBalance + si.FeeBalance) sp.InterestConfig.Cap.DailyAmount interestRounding
            // of the actual payments made on the day, sum any that are confirmed or written off
            let confirmedPaymentTotal =
                ap.ActualPayments
                |> Array.sumBy(fun ap -> match ap.ActualPaymentStatus with ActualPaymentStatus.Confirmed ap -> ap | ActualPaymentStatus.WriteOff ap -> ap | _ -> 0L<Cent>)
            // cap the simple interest against the total interest cap
            let cappedSimpleInterestM = Interest.Cap.cappedAddedValue sp.InterestConfig.Cap.TotalAmount sp.Principal a.CumulativeSimpleInterestM simpleInterestM
            // apply the cumulative simple interest to the accumulator
            let accumulator =
                { a with
                    CumulativeSimpleInterestM = a.CumulativeSimpleInterestM + cappedSimpleInterestM
                }
            // calculate any new interest accrued since the previous item, according to the interest method supplied in the schedule parameters
            let newInterestM =
                match sp.InterestConfig.Method with
                | Interest.Method.AddOn ->
                    if si.BalanceStatus <> ClosedBalance then
                        a.CumulativeSimpleInterestM + cappedSimpleInterestM
                        |> fun i ->
                            if i > initialInterestBalanceM then
                                i - initialInterestBalanceM
                            else
                                0m<Cent>
                        |> min cappedSimpleInterestM
                    else
                        0m<Cent>
                | Interest.Method.Simple -> simpleInterestM
            // ignore small amounts of interest that have accumulated by the last day of the schedule, with the allowance being proportional to the length of the schedule
            let calculateSettlementReduction m =
                if appliedPaymentDay = maxAppliedPaymentDay then
                    m - Interest.ignoreFractionalCents appliedPaymentCount m
                else
                    0m<Cent>
            // cap the new interest against the total interest cap
            let cappedNewInterestM, settlementReductionM =
                let cni = Interest.Cap.cappedAddedValue sp.InterestConfig.Cap.TotalAmount sp.Principal a.CumulativeInterest newInterestM
                calculateSettlementReduction cni
                |> max 0m<Cent>
                |> fun sr -> cni - sr, sr
            let settlementReductionL = settlementReductionM |> Cent.fromDecimalCent interestRounding
            // of the actual payments made on the day, sum any that are still pending
            let pendingPaymentTotal =
                ap.ActualPayments
                |> Array.sumBy(fun ap -> match ap.ActualPaymentStatus with ActualPaymentStatus.Pending ap -> ap | _ -> 0L<Cent>)
            // apportion the interest
            let interestPortionM =
                // if a refund is made and the settlement figure is postive, the payment should be apportioned to principal rather than interest (this likely represents a goodwill gesture so should directly benefit the customer)
                if confirmedPaymentTotal < 0L<Cent> && si.SettlementFigure.IsSome && si.SettlementFigure.Value >= 0L<Cent> then
                    0m<Cent>
                // otherwise, add new interest to the interest balance as normal
                else
                    cappedNewInterestM + si.InterestBalance
            // get the rounded interest portion
            let interestPortionL = interestPortionM |> Cent.fromDecimalCent interestRounding
            // update the accumulator
            let accumulator =
                { accumulator with
                    CumulativeScheduledPayments = a.CumulativeScheduledPayments + ScheduledPayment.total ap.ScheduledPayment
                    CumulativeActualPayments = a.CumulativeActualPayments + confirmedPaymentTotal + pendingPaymentTotal
                    CumulativeInterest = a.CumulativeInterest + cappedNewInterestM
                }
            // keep track of any excess payments made to offset against future payments due
            let extraPaymentsBalance = a.CumulativeActualPayments - a.CumulativeScheduledPayments - a.CumulativeGeneratedPayments
            // get the payment due
            let paymentDue = calculatePaymentDue si ap.ScheduledPayment.Original ap.ScheduledPayment.Rescheduled extraPaymentsBalance interestPortionL sp.PaymentConfig.Minimum
            // determine the total of any underpayment
            let underpaymentTotal =
                match ap.PaymentStatus with
                | MissedPayment ->
                    paymentDue
                | Underpayment ->
                    paymentDue - ap.NetEffect
                | _ ->
                    0L<Cent>
            // determine the total and details of any charges incurred
            let newChargesTotal, incurredCharges =
                if paymentDue = 0L<Cent> then
                    0L<Cent>, [||]
                else
                    ap.AppliedCharges
                    |> Array.sumBy _.Total, ap.AppliedCharges
            // apportion the charges
            let chargesPortion = newChargesTotal + si.ChargesBalance |> Cent.max 0L<Cent>
            // for future days, assume that the payment will be made in full and on schedule, yielding a full net effect and allowing meaningful inspection of the future schedule
            // (e.g. seeing if the schedule will be settled as agreed)
            let netEffect = if appliedPaymentDay > asOfDay then Cent.min ap.NetEffect paymentDue else ap.NetEffect
            // simplifies any refund apportionment by modifying the sign of certain values depending on whether the net effect is positive or negative
            let sign: int64<Cent> -> int64<Cent> = if netEffect < 0L<Cent> then (( * ) -1L) else id
            // get the rounded cumulative simple interest
            let cumulativeSimpleInterestL = accumulator.CumulativeSimpleInterestM |> Cent.fromDecimalCent interestRounding
            // 
            let generatedSettlementPayment, interestAdjustmentM =
                match sp.InterestConfig.Method with
                | Interest.Method.AddOn when si.BalanceStatus <> ClosedBalance ->
                    // get a settlement figure for the add-on interest method based on the actual simple interest accrued up to now
                    let settlement =
                        sp.Principal + cumulativeSimpleInterestL - accumulator.CumulativeActualPayments
                        |> fun s -> if abs s < int64 appliedPaymentCount * 1L<Cent> then 0L<Cent> else s
                    // determine whether an interest adjustment is required based on the difference between cumulative simple interest and the initial interest balance
                    let interestAdjustment =
                        if (ap.GeneratedPayment = ToBeGenerated || settlement <= 0L<Cent>) && si.BalanceStatus <> RefundDue && cappedNewInterestM = 0m<Cent> then // cappedNewInterest check here avoids adding an interest adjustment twice (one for generated payment, one for final payment)
                            accumulator.CumulativeSimpleInterestM - initialInterestBalanceM
                            |> Interest.ignoreFractionalCents 1
                            |> Interest.Cap.cappedAddedValue sp.InterestConfig.Cap.TotalAmount sp.Principal accumulator.CumulativeSimpleInterestM
                        else
                            0m<Cent>
                    settlement - settlementReductionL, interestAdjustment
                // otherwise, calculate this later (unless closed balance, as not applicable)
                | _ ->
                    0L<Cent>, 0m<Cent>
            // refine the capped new interest value using any interest adjustment
            let cappedNewInterestM' = cappedNewInterestM + interestAdjustmentM
            // get the rounded value of the interest adjustment
            let interestAdjustmentL = interestAdjustmentM |> Cent.fromDecimalCent interestRounding
            // refine the interest portion based on any interest adjustment, and again check against the total interest cap
            let interestPortionL' =
                interestPortionL + interestAdjustmentL
                |> Cent.toDecimalCent
                |> Interest.Cap.cappedAddedValue sp.InterestConfig.Cap.TotalAmount sp.Principal (Cent.toDecimalCent a.CumulativeInterestPortions)
                |> Cent.fromDecimalCent interestRounding
            // determine how much of the net effect can be apportioned and whether any immediate adjustments need to be made to the scheduled payment due to charges and interest, depending on settings
            let assignable, scheduledPaymentAdjustment =
                if netEffect = 0L<Cent> then
                    0L<Cent>, 0L<Cent>
                else
                    match sp.PaymentConfig.ScheduledPaymentOption with
                    | AsScheduled ->
                        sign netEffect - sign chargesPortion - sign interestPortionL', 0L<Cent>
                    | AddChargesAndInterest ->
                        sign netEffect, sign chargesPortion - sign interestPortionL'
            // refine the scheduled payment with any adjustment
            let scheduledPayment = { ap.ScheduledPayment with Adjustment = scheduledPaymentAdjustment }
            // apportion the fee
            let feePortion =
                match sp.FeeConfig with
                | Some feeConfig ->
                    match feeConfig.FeeAmortisation with
                    | Fee.FeeAmortisation.AmortiseBeforePrincipal ->
                        Cent.min si.FeeBalance assignable
                    | Fee.FeeAmortisation.AmortiseProportionately ->
                        feePercentage sp.Principal feeTotal
                        |> Percent.toDecimal
                        |> fun m ->
                            if (1m + m) = 0m then 0L<Cent>
                            else decimal assignable * m / (1m + m) |> Cent.round RoundUp |> Cent.max 0L<Cent> |> Cent.min si.FeeBalance
                | None ->
                    0L<Cent>
            // determine the value of any fee rebate in the event of settlement, depending on settings
            let feeRebateIfSettled =
                match sp.FeeConfig with
                | Some feeConfig ->
                    match feeConfig.SettlementRebate with
                    | Fee.SettlementRebate.ProRata ->
                        let originalFinalPaymentDay = sp.ScheduleConfig |> generatePaymentMap sp.StartDate |> Map.keys |> Seq.toArray |> Array.tryLast |> Option.defaultValue 0<OffsetDay>
                        calculateFee feeTotal appliedPaymentDay originalFinalPaymentDay
                    | Fee.SettlementRebate.ProRataRescheduled originalFinalPaymentDay ->
                        calculateFee feeTotal appliedPaymentDay originalFinalPaymentDay
                    | Fee.SettlementRebate.Balance ->
                        a.CumulativeFee
                    | Fee.SettlementRebate.Zero ->
                        0L<Cent>
                | None ->
                    0L<Cent>
            // refine the settlement figure depending on the interest method
            let generatedSettlementPayment' =
                match sp.InterestConfig.Method with
                | Interest.Method.AddOn ->
                    generatedSettlementPayment
                | _ ->
                    si.PrincipalBalance + si.FeeBalance - feeRebateIfSettled + interestPortionL' + chargesPortion
            // refine the fee portion and rebate if a rebate is actually applied on the day, i.e. if the net effect covers the settlement figure
            let feePortion', feeRebate =
                if ap.GeneratedPayment.IsToBeGenerated || feePortion > 0L<Cent> && generatedSettlementPayment' <= netEffect then
                    let feeRebate' =
                        match sp.InterestConfig.AprMethod with
                        | Apr.CalculationMethod.UnitedKingdom _ when feeRebateIfSettled > 0L<Cent> ->
                            // if the statutory rebate is higher than the fee rebate calculated above, use the higher figure
                            calculateStatutoryFeeRebate sp appliedPayments initialStats appliedPaymentDay window
                            |> Cent.max feeRebateIfSettled
                            |> Cent.min feeTotal
                        | _ ->
                            feeRebateIfSettled
                    Cent.max 0L<Cent> (si.FeeBalance - feeRebate'), feeRebate'
                else
                    sign feePortion, 0L<Cent>
            // apportion the principal
            let principalPortion = Cent.max 0L<Cent> (assignable - feePortion')
            // calculate the principal balance
            let principalBalance = si.PrincipalBalance - sign principalPortion
            // if any future payment creates a negative principal balance, adjust these figures accordingly
            let paymentDue', netEffect', principalPortion', principalBalance' =
                if ap.PaymentStatus = NotYetDue && feeRebate > 0L<Cent> && principalBalance < 0L<Cent> then
                    paymentDue + principalBalance, netEffect + principalBalance, sign principalPortion + principalBalance, 0L<Cent>
                else
                    paymentDue, netEffect, sign principalPortion, principalBalance
            // if any charges or interest are not fully covered by the actual payment total, determine the values to carry over to the next item
            let carriedCharges, carriedInterestL =
                if sign chargesPortion > sign netEffect then
                    chargesPortion - netEffect, interestPortionL
                elif netEffect = 0L<Cent> && interestPortionM < 0m<Cent> then
                    0L<Cent>, interestPortionL
                elif sign chargesPortion + sign interestPortionL' > sign netEffect then
                    0L<Cent>, interestPortionL - (netEffect - chargesPortion)
                else
                    0L<Cent>, 0L<Cent>
            // get the date equivalent of the offset day for further calculation
            let offsetDate = sp.StartDate.AddDays(int appliedPaymentDay)
            // determine the principal balance
            let balanceStatus = getBalanceStatus principalBalance'
            // calculate the interest balance as a decimal
            let interestBalanceM = si.InterestBalance + cappedNewInterestM' - Cent.toDecimalCent (interestPortionL' - carriedInterestL)
            // get the rounded interest balance
            let interestBalanceL = interestBalanceM |> decimal |> Cent.round interestRounding
            // creates an item that optionally creates a settlement
            let createScheduleItem isSettlement =
                // refine the payment status based on the balance status and whether this is a settlement
                let paymentStatus =
                    match si.BalanceStatus, isSettlement with
                    | ClosedBalance, _ ->
                        NoLongerRequired
                    | _, true ->
                        Generated
                    | RefundDue, _ when netEffect' < 0L<Cent> ->
                        Refunded
                    | RefundDue, _ when netEffect' > 0L<Cent> ->
                        Overpayment
                    | RefundDue, _ ->
                        NoLongerRequired
                    | _ when
                        ap.PaymentStatus <> InformationOnly
                        && paymentDue' = 0L<Cent>
                        && confirmedPaymentTotal = 0L<Cent>
                        && pendingPaymentTotal = 0L<Cent>
                        && GeneratedPayment.Total ap.GeneratedPayment = 0L<Cent> ->
                            NothingDue
                    | _ ->
                        ap.PaymentStatus
                // refine the settlement figure if necessary by subtracting any payment made on the same day, or nullifying it if there are payments pending (settlement cannot be made in this case)
                let settlementFigure =
                    match pendingPaymentTotal, ap.PaymentStatus, sp.InterestConfig.Method with
                    | pp, _, _ when pp > 0L<Cent> ->
                        ValueNone
                    | _, NotYetDue, _ 
                    | _, _, Interest.Method.AddOn ->
                        ValueSome generatedSettlementPayment'
                    | _ ->
                        ValueSome (generatedSettlementPayment' - netEffect')
                // deteremine the settlement balances or carried balances
                let balances, interestPortionL', generatedPayment =
                    if isSettlement then
                        // convert the generated payment placeholder with an actual settlement figure 
                        ((0L<Cent>, 0L<Cent>, 0m<Cent>, 0L<Cent>),
                        interestPortionL',
                        match ap.GeneratedPayment with
                        | ToBeGenerated -> GeneratedValue settlementFigure.Value
                        | gp -> gp)
                    else
                        // refine the interest portion by adding carried interest, and calculate the balances
                        let feeBalance = si.FeeBalance - feePortion' - feeRebate
                        let interestBalance = interestBalanceM |> Interest.ignoreFractionalCents 1
                        let chargesBalance = si.ChargesBalance + newChargesTotal - chargesPortion + carriedCharges
                        ((principalBalance', feeBalance, interestBalance, chargesBalance),
                        interestPortionL' - carriedInterestL,
                        ap.GeneratedPayment)
                // assign the separate balances
                let principalBal, feeBal, interestBal, chargesBal = balances
                // ensure the settlement figure is never more than the total balances
                let balanceTotal = principalBal + feeBal + Cent.fromDecimalCent sp.InterestConfig.Rounding interestBal + chargesBal
                let settlementFigure' = settlementFigure |> ValueOption.map(fun sf -> (balanceTotal, sf) ||> if sf < 0L<Cent> then Cent.max else Cent.min)
                // create the schedule item
                let scheduleItem = {
                    Window = window
                    OffsetDate = offsetDate
                    Advances = advances
                    ScheduledPayment = scheduledPayment
                    PaymentDue = paymentDue'
                    ActualPayments = ap.ActualPayments
                    GeneratedPayment = generatedPayment
                    NetEffect = if isSettlement then netEffect + GeneratedPayment.Total generatedPayment else netEffect'
                    PaymentStatus = paymentStatus
                    BalanceStatus = if isSettlement then ClosedBalance else balanceStatus
                    SimpleInterest = cappedSimpleInterestM
                    NewInterest = cappedNewInterestM'
                    NewCharges = incurredCharges
                    PrincipalPortion = if isSettlement then si.PrincipalBalance else principalPortion'
                    FeePortion = if isSettlement then si.FeeBalance - feeRebate else feePortion'
                    InterestPortion = interestPortionL'
                    ChargesPortion = if isSettlement then chargesPortion else chargesPortion - carriedCharges
                    FeeRebate = feeRebate
                    PrincipalBalance = principalBal
                    FeeBalance = feeBal
                    InterestBalance = interestBal
                    ChargesBalance = chargesBal
                    SettlementFigure = settlementFigure'
                    FeeRebateIfSettled = if not isSettlement && paymentStatus = NoLongerRequired then 0L<Cent> else feeRebateIfSettled
                }
                // calculate the rounding difference between the decimal and integer interest balances
                let interestRoundingDifferenceM = 
                    if not isSettlement && interestPortionL' = 0L<Cent> then
                        0m<Cent>
                    else
                        interestBalanceM - Cent.toDecimalCent interestBalanceL
                // returns the offset day, schedule item, generated payment, and interest rounding difference (zero in this case as it is already factored into the settlement figure)
                appliedPaymentDay, scheduleItem, (if isSettlement then settlementFigure'.Value else 0L<Cent>), interestRoundingDifferenceM

            // get the relevant type of item based on the intended purpose
            let offsetDay, scheduleItem, generatedPayment, interestRoundingDifferenceM =
                match ap.GeneratedPayment, settlementDay with
                | ToBeGenerated, SettlementDay.SettlementOnAsOfDay when asOfDay = appliedPaymentDay ->
                    createScheduleItem true
                | ToBeGenerated, SettlementDay.SettlementOn day when day = appliedPaymentDay ->
                    createScheduleItem true
                | GeneratedValue gv, _ ->
                    failwith $"Unexpected value: <i>{gv}</i>"
                | NoGeneratedPayment, _
                | ToBeGenerated, SettlementDay.NoSettlement
                | ToBeGenerated, SettlementDay.SettlementOn _
                | ToBeGenerated, SettlementDay.SettlementOnAsOfDay ->
                    createScheduleItem false

            // refine the accumulator values
            let accumulator' =
                { accumulator with
                    CumulativeScheduledPayments = accumulator.CumulativeScheduledPayments + scheduledPaymentAdjustment
                    CumulativeGeneratedPayments = a.CumulativeGeneratedPayments + generatedPayment
                    CumulativeFee = a.CumulativeFee + feePortion'
                    CumulativeInterest = accumulator.CumulativeInterest - interestRoundingDifferenceM
                    CumulativeInterestPortions = a.CumulativeInterestPortions + scheduleItem.InterestPortion
                }
            // return the values for the next scan iteration
            (offsetDay, scheduleItem), accumulator'
        ) (
            // initialise the values for the scan
            (0<OffsetDay>,
            { ScheduleItem.initial with
                OffsetDate = sp.StartDate
                Advances = [| sp.Principal |]
                PrincipalBalance = sp.Principal
                FeeBalance = feeTotal
                InterestBalance = initialInterestBalanceM
                SettlementFigure = ValueSome <| sp.Principal + feeTotal
                FeeRebateIfSettled =
                    match sp.FeeConfig with
                    | Some fc ->
                        match fc.SettlementRebate with
                        | Fee.SettlementRebate.Zero -> 0L<Cent>
                        | _ -> feeTotal
                    | None -> 0L<Cent>
            }), {
                CumulativeScheduledPayments = 0L<Cent>
                CumulativeActualPayments = 0L<Cent>
                CumulativeGeneratedPayments = 0L<Cent>
                CumulativeFee = 0L<Cent>
                CumulativeInterest = initialInterestBalanceM
                CumulativeInterestPortions = 0L<Cent>
                CumulativeSimpleInterestM = 0m<Cent>
            }
        )
        // separate and discard the accumulator
        |> Array.unzip
        |> fst
        // handle duplicated initial offset day
        |> fun a -> if a |> Array.filter(fun (siOffsetDay, _) -> siOffsetDay = 0<OffsetDay>) |> Array.length = 2 then a |> Array.tail else a
        // convert back to a map
        |> Map.ofArray
        // post-process missed payments or underpayments
        |> markMissedPaymentsAsLate

    /// wraps the amortisation schedule in some statistics, and optionally calculates the final APR (optional because it can be processor-intensive)
    let calculateStats sp settlementDay (items: Map<int<OffsetDay>, ScheduleItem>) =
        let finalItemDay, finalItem = items |> Map.maxKeyValue
        let items' = items |> Map.toArray |> Array.map snd
        let principalTotal = items' |> Array.sumBy _.PrincipalPortion
        let feeTotal = items' |> Array.sumBy _.FeePortion
        let interestTotal = items' |> Array.sumBy _.InterestPortion
        let chargesTotal = items' |> Array.sumBy _.ChargesPortion
        let feeRebate = finalItem.FeeRebate
        let finalPaymentDay = finalItemDay
        let requiredScheduledPaymentItems = items |> Map.filter(fun _ si -> ScheduledPayment.isSome si.ScheduledPayment && not si.PaymentStatus.IsNoLongerRequired)
        let actualPaymentItems = items |> Map.filter(fun _ si -> si.ActualPayments.Length > 0)
        {
            ScheduleItems = items
            FinalStats = {
                RequiredScheduledPaymentCount =
                    requiredScheduledPaymentItems
                    |> Map.count
                LastRequiredScheduledPaymentDay =
                    if Map.count requiredScheduledPaymentItems = 0 then
                        ValueNone
                    else
                        requiredScheduledPaymentItems
                        |> Map.maxKeyValue
                        |> fst
                        |> ValueSome
                FinalActualPaymentCount =
                    items'
                    |> Array.sumBy(fun asi -> Array.length asi.ActualPayments)
                LastActualPaymentDay =
                    if Map.count actualPaymentItems = 0 then
                        ValueNone
                    else
                        actualPaymentItems
                        |> Map.maxKeyValue
                        |> fst
                        |> ValueSome
                FinalCostToBorrowingRatio =
                    if principalTotal = 0L<Cent> then
                        Percent 0m
                    else
                        decimal (feeTotal + interestTotal + chargesTotal) / decimal principalTotal
                        |> Percent.fromDecimal
                        |> Percent.round 2
                EffectiveInterestRate =
                    if finalPaymentDay = 0<OffsetDay> || principalTotal + feeTotal - feeRebate = 0L<Cent> then
                        0m
                    else
                        decimal interestTotal / decimal (principalTotal + feeTotal - feeRebate) / decimal finalPaymentDay
                    |> Percent.fromDecimal
                    |> Interest.Rate.Daily
            }
        }

    /// generates an amortisation schedule and final statistics
    let generate sp settlementDay trimEnd actualPayments =
        let asOfDay = sp.AsOfDate |> OffsetDay.fromDate sp.StartDate
        let simpleSchedule = Scheduling.calculate sp
        let scheduledPayments =
            simpleSchedule.Items
            |> Array.filter (_.ScheduledPayment >> ScheduledPayment.isSome)
            |> Array.map(fun si -> si.Day, { si.ScheduledPayment with Original = si.ScheduledPayment.Original } )
            |> Map.ofArray

        let amortisationSchedule =
            scheduledPayments
            |> applyPayments asOfDay sp.StartDate settlementDay sp.ChargeConfig sp.PaymentConfig.Timeout actualPayments
            |> calculate sp settlementDay simpleSchedule.Stats
            |> if trimEnd then Map.filter(fun _ si -> si.PaymentStatus <> NoLongerRequired) else id
            |> calculateStats sp settlementDay

        { AmortisationSchedule = amortisationSchedule; SimpleSchedule = simpleSchedule }
