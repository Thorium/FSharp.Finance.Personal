namespace FSharp.Finance.Personal

open Scheduling
open Quotes

/// functions for rescheduling payments after an original schedule failed to amortise
module Rescheduling =

    open Calculation
    open DateDay

    /// the parameters used for setting up additional items for an existing schedule or new items for a new schedule
    [<RequireQualifiedAccess>]
    type RescheduleParameters = {
        /// whether the fee should be pro-rated or due in full in the new schedule
        FeeettlementRebate: Fee.SettlementRebate
        /// whether the plan is autogenerated or a manual plan provided
        PaymentSchedule: ScheduleConfig
        /// how to handle interest on negative principal balances
        RateOnNegativeBalance: Interest.Rate
        /// any promotional or introductory offers during which a different interest rate is applicable
        PromotionalInterestRates: Interest.PromotionalRate array
        /// whether and when to generate a settlement figure, otherwise just a statement will be generated
        SettlementDay: SettlementDay voption
    }

    /// take an existing schedule and reschedule the remaining payments e.g. to allow the customer more time to pay
    let reschedule sp (rp: RescheduleParameters) actualPayments =

        // get the settlement quote
        let quote = getQuote SettlementDay.SettlementOnAsOfDay sp actualPayments

        // create a new payment schedule either by auto-generating it or using manual payments
        let newPaymentSchedule =
            match rp.PaymentSchedule with
            | AutoGenerateSchedule _ ->
                Scheduling.calculate { sp with ScheduleConfig = rp.PaymentSchedule }
                |> _.Items
                |> Array.filter (_.ScheduledPayment >> ScheduledPayment.isSome)
                |> Array.map(fun si -> si.Day, si.ScheduledPayment)
            | FixedSchedules fixedSchedules ->
                fixedSchedules
                |> Array.map(fun fs ->
                    let scheduledPayment =
                        match fs.ScheduleType with
                        | ScheduleType.Original -> ScheduledPayment.quick (ValueSome fs.PaymentValue) ValueNone
                        | ScheduleType.Rescheduled rescheduleDay -> ScheduledPayment.quick ValueNone (ValueSome { Value = fs.PaymentValue; RescheduleDay = rescheduleDay })
                    UnitPeriod.generatePaymentSchedule (UnitPeriod.PaymentCount fs.PaymentCount) UnitPeriod.Direction.Forward fs.UnitPeriodConfig
                    |> Array.map(fun d -> OffsetDay.fromDate sp.StartDate d, scheduledPayment)
                )
                |> Array.concat
            | CustomSchedule payments ->
                payments
                |> Map.toArray

        // append the new schedule to the old schedule up to the point of settlement
        let oldPaymentSchedule =
            quote.RevisedSchedules.AmortisationSchedule.ScheduleItems
            |> Map.filter(fun _ si -> ScheduledPayment.isSome si.ScheduledPayment)
            |> Map.map(fun _ si -> si.ScheduledPayment)
            |> Map.toArray

        // configure the parameters for the new schedule
        let spNew =
            { sp with
                ScheduleConfig = [| oldPaymentSchedule; newPaymentSchedule |] |> Array.concat |> mergeScheduledPayments |> CustomSchedule
                FeeConfig = sp.FeeConfig |> Option.map(fun fc -> { fc with SettlementRebate = rp.FeeettlementRebate })
                InterestConfig =
                    { sp.InterestConfig with
                        InitialGracePeriod = 0<DurationDay>
                        PromotionalRates = rp.PromotionalInterestRates
                        RateOnNegativeBalance = rp.RateOnNegativeBalance
                    }
            }

        // create the new amortisation schedule
        let rescheduledSchedules = Amortisation.generate spNew rp.SettlementDay true actualPayments

        // return the results
        {| OldSchedules = quote.RevisedSchedules; NewSchedules = rescheduledSchedules |}

    /// parameters for creating a rolled-over schedule
    [<RequireQualifiedAccess>]
    type RolloverParameters = {
        /// the final payment day of the original schedule
        OriginalFinalPaymentDay: int<OffsetDay>
        /// the scheduled payments or the parameters for generating them
        PaymentSchedule: ScheduleConfig
        /// options relating to interest
        InterestConfig: Interest.Config
        /// options relating to payment
        PaymentConfig: PaymentConfig
        /// how to handle any outstanding fee balance
        FeeHandling: Fee.FeeHandling
    }

    /// take an existing schedule and settle it, then use the result to create a new schedule to pay it off under different terms
    let rollOver sp (rp: RolloverParameters) actualPayments =

        // get the settlement quote
        let quote = getQuote SettlementDay.SettlementOnAsOfDay sp actualPayments

        // process the quote and extract the portions if applicable
        let principalPortion, feePortion, feeRebateIfSettled =
            match quote.QuoteResult with
            | PaymentQuote ({ Apportionment = a } as pq) ->
                match rp.FeeHandling with
                | Fee.FeeHandling.CapitaliseAsPrincipal -> a.PrincipalPortion + a.FeePortion + a.InterestPortion + a.ChargesPortion, 0L<Cent>, pq.FeeRebateIfSettled
                | Fee.FeeHandling.CarryOverAsIs -> a.PrincipalPortion + a.InterestPortion + a.ChargesPortion, a.FeePortion, pq.FeeRebateIfSettled
                | Fee.FeeHandling.WriteOffFeeBalance -> a.PrincipalPortion + a.InterestPortion + a.ChargesPortion, a.FeePortion, pq.FeeRebateIfSettled
            | _ -> failwith "Unable to obtain quote for rollover"

        // configure the parameters for the new schedule
        let spNew =
            { sp with
                StartDate = sp.AsOfDate
                Principal = principalPortion
                ScheduleConfig = rp.PaymentSchedule
                FeeConfig =
                    sp.FeeConfig
                    |> Option.bind(fun fc ->
                        match rp.FeeHandling with
                        | Fee.FeeHandling.CarryOverAsIs ->
                            { fc with
                                FeeType = Fee.CustomFee ("Rollover Fee", Amount.Simple feePortion)
                                SettlementRebate =
                                    if feeRebateIfSettled = 0L<Cent> then
                                        Fee.SettlementRebate.Zero
                                    else
                                        match fc.SettlementRebate with
                                        | Fee.SettlementRebate.ProRata
                                        | Fee.SettlementRebate.ProRataRescheduled _ ->
                                            Fee.SettlementRebate.ProRataRescheduled rp.OriginalFinalPaymentDay
                                        | _ as fsr ->
                                            fsr
                            }
                            |> Some
                        | _ ->
                            None
                    )
                InterestConfig = rp.InterestConfig
                PaymentConfig = rp.PaymentConfig
            }

        // create the new amortisation schedule
        let rolledOverSchedules = Amortisation.generate spNew ValueNone true Map.empty

        // return the results
        {| OldSchedules = quote.RevisedSchedules; NewSchedules = rolledOverSchedules |}
